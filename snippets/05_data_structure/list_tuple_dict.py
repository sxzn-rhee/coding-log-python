# 리스트 (순서 존재)
아이스크림1 = "월드콘"
아이스크림2 = "메로나"
아이스크림3 = "스크류바"

아이스크림 = ["월드콘", "메로나", "스크류바"]

#리스트 인덱싱
print(아이스크림[0])
print(아이스크림[1])
# print(아이스크림[3])은 인덱싱 에러

# 리스트 슬라이싱
아이스크림 = ["월드콘", "메로나", "스크류바"]
print(아이스크림[0:2])
print(아이스크림[1:3])

# 리스트 수정: 인덱싱을 통해 새로운 값을 바인딩
아이스크림 = ["월드콘", "메로나", "스크류바"]

아이스크림[2] = "빵빠레"
print(아이스크림)

# 리스트 추가 : append() -> 리스트의 끝에 원소 추가
버킷리스트 = []
버킷리스트.append("파이썬 배우기")
버킷리스트.append("책 집필")
print(버킷리스트)

#리스트 삽입 : 리스트.insert(인덱스, 원소) -> 전에 존재하던 원소가 사라지는게 아니라 뒤로 밀림.
버킷리스트 = ["파이썬배우기", "책집필", "자격증공부"]
버킷리스트.insert(2, "해외여행")
print(버킷리스트)

#리스트 원소 삭제 : del 리스트[인덱스] (함수와 달리 키워드 사용)
버킷리스트 = ["파이썬배우기", "책집필", "해외여행", "자격증공부"]
del 버킷리스트[2]
print(버킷리스트)

#리스트 확장 : 첫번째 리스트+두번째 리스트 연결 : extend 함수
num1 = [1, 2, 3]
num2 = [4, 5, 6]
num1.extend(num2)
print(num1)

#리스트의 최댓값과 최솟값 : max, min
시세 = [47000, 46800, 45000, 47750, 47850]
최댓값 = max(시세)
최솟값 = min(시세)
print(최댓값, 최솟값)

#리스트 정렬 
# 1. 오름차순: sorted 내장함수 
price = [533, 504, 498, 506, 489]
price1 = sorted(price)
print(price1)
# 2. 내림차순: sorted 함수_reverse=True 파이썬 내장 함수 
price = [533, 504, 498, 506, 489]
price2 = sorted(price, reverse=True)
print(price2)
# 3. 원본 리스트 자체를 정렬: sort() -> price자체가 바뀜. 제자리 정렬(in-place) : 리스트 타입 전용 메서드
price = [533, 504, 498, 506, 489]
price.sort()
print(price)

#리스트 연결: 두 리스트를 덧셈 연산자로 더하기
과자 = ["치토스", " 썬칩", "양파링"]
아이스크림 = ["구구콘", "메로나", "비비빅"]
구매품목 = 과자 + 아이스크림 
print(구매품목)

#인덱스 찾기 cf. 원소가 리스트에 존재하지 않으면 ValueError
과자  = ["치토스", "썬칩", "양파링"]
print(과자.index("양파링"))

#p.58 연습문제
final = [59600, 60900, 60700, 61900, 62100]
avg = sum(final) / len(final)
print(f"{avg: ,}")

price = [1463, 1483, 1498, 1517, 1530]
price_max = max(price)
pirce_min = min(price)
print (price_max, pirce_min)

#3.2 튜플 (리스트: 순서 존재, 수정 가능), (튜플: 순서 존재, 수정 불가능)
#튜플 생성
시세 = (533, 504, 498, 506, 489)
print(시세)
print(type(시세))

#튜플 인덱싱과 슬라이싱(리스트와 동일)
시세 = (533, 504, 498, 506, 489)
print(시세[0])
print(시세[1])

#인덱싱&슬라이싱: 대괄호 사용(리스트 생성) 
print(시세[0:2])
 
#리스트와 달리 튜플은 수정 불가
시세 = (533, 504, 498, 506, 489)
#시세[0] = 100 (#에러)

# 리스트와 튜플은 서로 형변환이 가능
mylist = [1,2,3]
result1 = tuple(mylist)

mytuple = (1, 2, 3)
result2 = list(mytuple)

#3.3 딕셔너리: 어떤 값과 그 값에 대한 레이블을 동시에 저장 가능 (레이블:key, 값:value)
#딕셔너리의 기호: 중괄호({}), key는 중복될 수 없음
아이스크림 = {"월드콘": 2000, "메로나": 1000, "스크류바": 800}

#딕셔너리 인덱싱 (원소 간에 순서가 존재하지 않음), key 값을 통해서 value 얻어야함
아이스크림 = {"월드콘": 2000, "메로나": 1000, "스크류바": 800}
print(아이스크림["월드콘"])

#딕셔너리 인덱싱 할 때 존재하지 않은 key값 사용시 error 발생
#-> 그래서 get함수 사용. 
아이스크림 = {"월드콘": 2000, "메로나": 1000, "스크류바": 800}
print(아이스크림.get("월드콘"))
print(아이스크림.get("메로나"))

#딕셔너리 수정 : 딕셔너리[키] = 새로운 값
아이스크림 = {"월드콘": 2000, "메로나": 1000, "스크류바": 800}
아이스크림["월드콘"] = 2500

#딕셔너리에 값 추가 : 딕셔너리 수정과 동일 (key가 딕셔너리에 없으면 key/value쌍을 추가)
아이스크림 = {}
아이스크림["월드콘"] = 2000
아이스크림["메로나"] = 1000
아이스크림["스크류바"] = 800
print(아이스크림)

#딕셔너리 원소 삭제: key를 통해 이루어짐 : del 딕셔너리[key]
아이스크림 = {"월드콘": 2000, "메로나": 1000, "스크류바": 800}
del 아이스크림["월드콘"]
print(아이스크림)

print(아이스크림.keys())
print(아이스크림.values())

#p.67 연습문제
#문제 1번
samsung = {
    "시가": 58000, 
    "고가": 59000, 
    "저가": 57000, 
    "종가": 58500
    }
print(samsung)

#3.4 2차원 데이터
apart = [
    [101, 102],
    [201, 202],
    [301, 302]
]
print(apart[0])

일층 = apart[0]
print(일층[0])
print(일층[1])

print(apart[0][0])
print(apart[0][1])

#딕셔너리 중첩(key가 다시 딕셔너리 타입의 value를 갖는 것)
고객정보 = {
    "이름": "조대표", 
    "직업": "직장인",
    "주소": {
        "도": "경기도",
        "시": "김포시",
        "동": "풍무동"
    }
}
print(고객정보["이름"])
print(고객정보["주소"]["도"])

#p.71 연습문제
#1번
day1 = {
    "date": "2022-06-01",
    "open": 535,
    "high": 565, 
    "low": 510, 
    "close": 533
}

day2 = {
    "date": "2022-06-02",
    "open": 540,
    "high": 550,
    "low": 520, 
    "close": 545
}
day3 = {
    "date": "2022-06-03",
    "open": 545,  
    "high": 580,
    "low": 540,
    "close": 550
}

stock_data = [day1, day2, day3]
import pprint
pprint.pprint(stock_data)
#2번
information = [
    {"월": "2021-05", "예정작": ["크루즈 패밀리", "극장판 콩순이", "아이들은 즐겁다"]},
    {"월": "2021-06", "예정작": ["까치발", "킬러의 카운슬러", "꿈꾸는 고양이"]}
]

