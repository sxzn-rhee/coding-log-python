# 03. 자료구조
파이썬의 자료구조: 여러 개의 데이터를 다루는데 필요한 기술
*** 세 가지 기본 자료구조: 리스트, 튜플, 딕셔너리 ***


## 3.1 리스트 
: 순서 존재 + 수정할 수 있는 자료구조 코드::[] 사용
### 리스트 인덱싱 
- 순서 존재, 정숫값으로 인덱싱 가능 
```bash
아이스크림 = ["월드콘", "메로나", "스크류바"]
print(아이스크림[0])
```
### 리스트 슬라이싱 
- 문자열과 마찬가지로 리스트도 슬라이싱 가능
```bash
아이스크림 = ["월드콘", "메로나", "스크류바"]
print(아이스크림[0:2])
``` 
### 리스트 수정
- 인덱싱을 통해 새로운 값 바인딩하기 
```bash 
아이스크림 = ["월드콘", "메로나", "스크류바"]
아이스크림[2]  = "빵빠레" 
print(아이스크림)
```
### 리스트 추가 
- **append 함수(매서드)** : 리스트의 끝에 원소를 추가 
ex.리스트.append("파이썬 배우기")
```bash
버킷리스트 = []
버킷리스트.append("파이썬 배우기")
버킷리스트.append("책 집필")
print(버킷리스트)
```
### 리스트 삽입
- **insert 함수(매서드)** : 특정 위치에 원소 삽입 
ex.리스트.insert(인덱스, 원소)
```bash
버킷리스트  = ["파이썬배우기", "책집필", "자격증공부"]
버킷리스트.insert(2, "해외여행")
print(버킷리스트)
```
### 리스트 원소 삭제 
- **del 리스트[인덱스]**: 특정 위치의 원소를 삭제할 수 있음
```bash
버킷리스트 = ["파이썬배우기", "책집필", "해외여행", "자격증공부"]
del 버킷리스트[2]
print(버킷리스트)
```
### 리스트 확장
- **리스트.extend(리스트)** : 두 개의 리스트가 있을 때 첫번쨰 리스트에 두 번쨰 리스트를 연결하여 확장
```bash
num1 = [1, 2, 3]
num2 = [4, 5, 6]
num1.extnd(num2)
print(num1)
```
### 리스트의 최댓값과 최솟값
- max(리스트 이름), min(리스트 이름): 내장함수
```bash
시세 = [47000. 46800, 45800, 47750, 47850]
최대값 = max(시세)
최솟값 = min(시세)
``` 
### 리스트 정렬
- **sorted 내장함수** , **sort 매서드** 
<내장함수>
- 원본은 그대로 유지, 오름차순으로 정렬된 리스트를 반환
- 오름차순
```bash
price = [533, 504, 498, 506, 489] 
price1 = sorted(price)   #오름차순 정렬
print(price1)
```
- 내림차순 : reverse = True 사용
```bash
price = [533, 504, 498, 506, 489]
price2 = sorted(price, reverse = True) #내림차순 정렬
print(price2)
``` 
<매서드>
- 원본 리스트 자체를 정렬
```bash
price = [533, 504, 498, 506, 489]
price.sort()
print(price)
``` 
### 리스트 연결 
- 두 리스트를 덧셈 연산자로 더하면 두 개의 리스트를 연결해서 새로운 리스트 생성
```bash
과자 = ["치토스", "썬칩", "양파링"]
아이스크림 = ["구구콘", "메로나", "비비빅"]
구매품목 = 과자 + 아이스크림
print(구매품목)
``` 
### 인덱스 찾기
- 리스트에 어떤 원소가 몇 번쨰 있는지 알아야 하는 경우 사용
ex. 원소를 삭제하기 위해서 ```del 리스트[인덱스]``` 형태: 원소가 위치하는 인덱스 필요
```bash
과자 = ["치토스", "썬칩", "양파링"]
과자.index("양파링") #원소가 위치하는 인덱스 돌려줌
과자.index("포카칩") #원소가 리스트에 존재하지 않으면 value error
```

## 3.2 튜플
- 파이썬 튜플(tuple): 순서가 있고, 수정은 불가능한 자료구조
(리스트와는 수정가능 여부에 차이가 존재)
- 리스트: [], 변경/인덱싱/슬라이싱/추가/삽입/삭제 지원
- 튜플: (), 변경/인덱싱/슬라이싱 지원, 추가/삽입/삭제 미지원

### 튜플 생성
- 한 번 생성시 원소의 값 변경 불가능
```bash
시세 = (533, 504, 498, 506, 489)
print(시세)
print(type(시세)) #class 'tuple'
```
### 튜플 인덱싱과 슬라이싱
- 순서가 존재하기 때문에 인덱싱과 슬라이싱 가능
```bash
시세 = (533, 504, 498, 506, 489)
print(시세[0])
print(시세[1])
```
- 튜플의 기호는 괄호이지만 인덱싱과 슬라이싱 할 때는 대괄호 기호 사용
```bash
print(시세[0:2])
```
### 튜플 수정
- 튜플은 수정 불가함
```bash
시세 = (533, 504, 498, 506, 489)
시세[0] = 100 #에러
``` 
### 리스트와 튜플의 형변환
- tuple(리스트) , list(튜플)
```bash
mylist = [1, 2, 3]
result1 = tuple(mylist) #리스트를 튜플로 변환

mytuple = (1,2,3)
result2 = list(mytuple) #튜플을 리스트로 변환
```

## 3.3 딕셔너리
- 어떤 값과 그 값에 대한 레이블(label)을 동시에 저장할 수 있는 자료구조
- 레이블: key, 값: value
- {}, 리스트나 튜플과 같이 저장된 원소 간에 순서가 존재하지 않음
```bash
# ex. 
아이스크림 = {
    "월드콘": 2000, 
    "메로나": 1000, 
    "스크류바": 800
}
```
### 딕셔너리 인덱싱
- key 값을 통해서 value 값을 얻을 수 있음
```bash
아이스크림 = {
    "월드콘": 2000, 
    "메로나": 1000, 
    "스크류바": 800
}

print(아이스크림["월드콘"])
``` 
- 딕셔너리 인덱싱에 존재하지 않는 Key 값 사용시 에러 발생
- get 함수 사용 : key가 존재하면 key 의 value 리턴, key가 존재하지 않으면 none이라는 값을 리턴
- ```딕셔너리.get(key값)```
```bash
아이스크림 = {
    "월드콘": 2000, 
    "메로나": 1000, 
    "스크류바": 800
}
   
print(아이스크림.get("월드콘"))
print(아이스크림.get("메로나"))
```
### 딕셔너리 수정
- 딕셔너리[키] = 새로운 값
```bash
아이스크림["월드콘"] = 2500 
#등호를 기준으로 오른쪽 먼저 실행 
#2,500 이라는 값이 메모리에 올라가고 이를 "월드콘"이라는 key가 바인딩
```
### 딕셔너리에 값 추가
- 비어있는 딕셔너리 생성 후, 값을 추가
```bash
아이스크림 = {}

아이스크림["월드콘"] = 2000
아이스크림["메로나"] = 1000
아이스크림["스크류바"] = 800
#해당 키에 대응하는 값이 있다면 value값이 업데이트됨
#key가 없다면 key,value쌍이 딕셔너리에 추가됨
```
### 딕셔너리 원소 삭제
```del 딕셔너리[key]```
- key는 딕셔너리 내에서 유일하기 때문에 key를 통해 key와 value삭제
```bash
아이스크림 = {
    "월드콘" : 2000, 
    "메로나" : 1000,
    "스크류바" : 800
}

del 아이스크림["월드콘"]
print(아이스크림)
```
### 딕셔너리 key, value 얻기
- key값들 또는 value 값들만 필요한 경우
- 딕셔너리.keys()
- 딕셔너리.values()
```bash
아이스크림 = {  
    "월드콘": 2000,
    "메로나": 1000, 
    "스크류바": 800
}

print(아이스크림.keys())  # key값만 얻기
print(아이스크림.values())  # values값만 얻기
```

## 3.4 이차원 데이터
- 자료구조 안에 자료구조 넣기
### 딕셔너리 중첩
```bash
고객정보 = {
    "이름": "조대표", 
    "직업": "직장인",
    "주소": {
        "도": "경기도",
        "시": "김포시",
        "동": "풍무동"
    }
}
print(고객정보["이름"])
print(고객정보["주소"]["도"])
```


### 헷갈렸던 부분
- 메서드와 내장함수의 활용 차이 
ex. sorted() : 내장함수
    리스트.sort() : 메서드